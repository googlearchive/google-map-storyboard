<!--
The 'google-map-storyboard' renders a Google Map with 'google-map-scene' elements.

<b>Example</b> - Add scenes to the map and traverse them linearly:

    <style>
      google-map-storyboard {
        height: 600px;
      }
    </style>
    <google-map-storyboard>
      <google-map-scene address="Sydney, Australia" zoom="5">This is Sydney!</google-map-scene>
      <google-map-scene address="Zurich, Switzerland"></google-map-scene>
    </google-map-storyboard>


@element google-map-storyboard
@homepage https://github.com/googlemaps/google-map-storyboard
-->
<!--
Fired when the storybord's google map is ready to be rendered.

@event google-map-storyboard-ready
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../google-apis/google-apis.html">
<link rel="import" href="google-map-scene.html">

<polymer-element name="google-map-storyboard" attributes="apiKey current">
<template>
  <style>

    :host {
      position: relative;
      display: block;
      height: 100%;
    }

    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    #sceneMedia {
      display: inline-block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 300px;
      word-break: break-all; 
      word-wrap: break-word;
      background-color: #ffffff;
      border: 1px solid black;
      padding: 10px 10px 10px 10px;
      font-family: Roboto;
      font-size: 14px;
      font-weight: 300;
    }
    
    #image {
      display: inline-block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    #toggle {
      display: inline-block;
      position: absolute;
      height: 15px;
      font-size: 0.75em;
      background-color: #ffffff;
      border: 1px solid gray;
    } 

    button {
      opacity: 0.5;
      font-size: 1.5em;
      outline: none;
      border-radius: 50%;
      background-color: #fff;
    }

    button:hover {
      opacity: 1;
    }
    
  </style>

  <google-maps-api apiKey="{{apiKey}}" version="3.exp" libraries="places,geometry" on-api-load="{{mapApiLoaded}}"></google-maps-api>

  <div id="map"></div>
  <div id="sceneMedia"></div>
  <div id="image"></div>
  <div id="toggle">Hide content</div>

  <content id="scenes" select="google-map-scene"></content>
</template>


<script>
(function() {
  Polymer({

    /**
     * Array of the google-map-scenes contained within the storyboard.
     * 
     * @property scenes
     * @type Array.google-map-scene
     * @default null
     */
    scenes: null,

    /**
     * The google map used in the storyboard.
     * 
     * @property map
     * @type google.maps.Map
     * @default null
     */
    map: null,

    /**
     * The Google Map API key. To obtain an API key, 
     * see developers.google.com/maps/documentation/javascript/tutorial#api_key.
     * 
     * @attribute apiKey
     * @type string
     * @default null
     */
    apiKey: null,

    publish: {
      /**
       * The id of the scene to be shown.
       * 
       * @attribute current
       * @type String
       * @default null
       */
      current: {value: null, reflect: true}
    },

    /**
     * The index of the upcoming scene.
     * 
     * @property index
     * @type Number
     * @default 0
     */
    index: 0,

    /**
     * The current scene. Initialised to the first scene.
     *
     * @property currentScene
     * @type google-map-scene
     * @default null
     */
    currentScene: null,

    /**
     * Array of the scene locations.
     *
     * @property totalPath
     * @type Array.google.maps.LatLng
     * @default null
     */
    totalPath: null,

    mapApiLoaded: function() {
      this.totalPath = this.totalPath || [];
      this.updateScenes();
    },

    initialiseMap: function() {
      if (!this.map) {
        var mapOptions = {
          center: this.currentScene.location,
          zoom: this.currentScene.zoom
        };
        this.map = new google.maps.Map(this.$.map, mapOptions);
        this.makeButton("prev", "Previous", "<", 
            google.maps.ControlPosition.LEFT_CENTER, this.getPrev);
        this.makeButton("next", "Next", ">", 
            google.maps.ControlPosition.RIGHT_CENTER, this.getNext);
        this.updateControls();
        this.fire('google-map-storyboard-ready');
        this.contentInteractivity();
      }
    },

    contentInteractivity: function(){
      var media = this.$.sceneMedia;
      var image = this.$.image;
      var toggle = this.$.toggle;
      google.maps.event.addDomListener(toggle,'click', function() {
        if (image.style.display === 'none'&& media.style.display === 'none') {
          toggle.innerHTML = "Hide content";
          if (this.currentScene.firstChild instanceof HTMLImageElement) {
            image.style.display = 'inline-block';
          } else {
            media.style.display = 'inline-block';
          }
        } else {
          toggle.innerHTML = "Show content";
          image.style.display = 'none';
          media.style.display = 'none';
        }
      }.bind(this));
      google.maps.event.addListener(this.map, 'dblclick', turnOffContent);
      google.maps.event.addListener(this.map, 'drag', turnOffContent);
      function turnOffContent() {
        image.style.display = 'none';
        media.style.display = 'none';
        toggle.innerHTML = "Show content";
        toggle.style.display = 'inline-block';
      }
    },

    updateScenes: function() {
      this.scenes = Array.prototype.slice.call(
          this.$.scenes.getDistributedNodes());
      this.updateLocations();
    },

    updateContent: function() {
      var media = this.$.sceneMedia;
      var image = this.$.image
      var currentNode = this.currentScene.firstChild;
      var toggle = this.$.toggle;
      if (currentNode instanceof HTMLImageElement) {
        image.innerHTML = currentNode.outerHTML;
        media.style.display = 'none';
        if (image.innerHTML) {
          image.style.display = 'inline-block';
        }
      }
      else {
        media.innerHTML = currentNode.textContent;
        image.style.display = 'none';
        if (media.innerHTML) {
          media.style.display = 'inline-block';
        }
      }
      var imageListener = google.maps.event.addDomListener(media, 'click', changeContent.bind(this));
      var mediaListener = google.maps.event.addDomListener(image, 'click', changeContent.bind(this));
      function changeContent() {
        if (currentNode.nextSibling != null){
          currentNode = currentNode.nextSibling;
          if (currentNode instanceof HTMLImageElement) {
            image.innerHTML = currentNode.outerHTML;
            media.style.display = 'none';
            if (image.innerHTML) {
              image.style.display = 'inline-block';
            }
          }
          else {
            media.innerHTML = currentNode.textContent;
            image.style.display = 'none';
            if (media.innerHTML) {
              media.style.display = 'inline-block';
            }
          }
        } else {
          currentNode = this.currentScene.firstChild;
          if (currentNode instanceof HTMLImageElement) {
            image.innerHTML = currentNode.outerHTML;
            media.style.display = 'none';
            if (image.innerHTML) {
              image.style.display = 'inline-block';
            }
          }
          else {
            media.innerHTML = currentNode.textContent;
            image.style.display = 'none';
            if (media.innerHTML) {
              media.style.display = 'inline-block';
            }
          }
        }
      }
    },

    updateLocations: function() {
      this.currentScene = this.currentScene || this.scenes[this.index];
      this.geocoder = this.geocoder || new google.maps.Geocoder();
      for (var i = 0; i < this.scenes.length; ++i) {
        var address = this.scenes[i].address;
        (function(index) {
          this.geocoder.geocode( {address: address}, function(place, status) {
            if (status == google.maps.GeocoderStatus.OK) {
              var scene = this.scenes[index];
              scene.location = place[0].geometry.location;
              this.totalPath[index] = scene.location;
              if (scene === this.currentScene) {
                this.index = index;
                this.current = scene.id;
                this.initialiseMap();
                this.updateContent();
              }
            }
          }.bind(this));
        }.bind(this))(i);
      }
    },

    currentChanged: function() {
      var scene = document.getElementById(this.current);
      if (!scene || scene.element.name != 'google-map-scene') {
        return;
      }
      if (this.scenes) {
        var sceneIndex = this.scenes.indexOf(scene);
        if (sceneIndex != this.index) {
          this.fitBounds([sceneIndex, this.index]);
          this.index = sceneIndex;
        }
      } else {
        this.currentScene = scene;
      }
      google.maps.event.removeListener(imageListener);
      google.maps.event.removeListener(mediaListener)
    },

    indexChanged: function() {
      if (this.map) {
        this.updateControls();
      }
    },

    getPrev: function() {
      if (this.index > 0) {
        var from = this.index.valueOf();
        this.index--;
        this.fitBounds([from, from - 1]);
      }
    },

    getNext: function() {
      if (this.index < this.scenes.length - 1) {
        var from = this.index.valueOf();
        this.index++;
        this.fitBounds([from, from + 1]);
      }
    },

    updateControls: function() {
      var control = this.map.controls[google.maps.ControlPosition.LEFT_CENTER];
      if (this.index < 1) {
        this.prevButton = this.prevButton || control.removeAt(0);
      } else if (this.prevButton) {
        control.insertAt(0, this.prevButton);
        this.prevButton = null;
      }

      control = this.map.controls[google.maps.ControlPosition.RIGHT_CENTER];
      if (this.index > this.scenes.length - 2) {
        this.nextButton = this.nextButton || control.removeAt(0);
      } else if (this.nextButton) {
        control.insertAt(0, this.nextButton);
        this.nextButton = null;
      }
    },

    totalPathChanged: function() {
      if (this.map && this.index < this.totalPath.length) {
        this.prevLine = this.prevLine || this.makePolyline(0.4);
        this.nextLine = this.nextLine || this.makePolyline(0.2);

        var prevPath = Array.prototype.slice.call(this.totalPath, 0,
            this.index + 1);
        this.prevLine.setPath(prevPath);
        var nextPath = Array.prototype.slice.call(this.totalPath,
            this.index).reverse();
        this.nextLine.setPath(nextPath);
      }
    },

    /**
     * The handler given will be executed when
     * the next `idle` map event is fired.
     *  - Only one handler is executed for each event.
     *  - Each handler is only executed at most once.
     *  - Overrides the previous handler.
     *
     * @method uponMapIdle
     */
    uponMapIdle: function(handler) {
      google.maps.event.removeListener(this.idleListener);
      this.idleListener = new google.maps.event.addListenerOnce(this.map,
          'idle', handler.bind(this));
    },

    /**
     * Fit the bounds of the map to the given scene locations.
     * The first stage of a transition to a scene.
     * The transition to a scene:
     *   - `fitBounds -> panToScene -> activateScene`
     *   - each change of state [`->`] occurs when the map is `idle`
     *
     * @method fitBounds
     * @param Array.Number - indices of scenes (and their locations).
     */
    fitBounds: function(indices) {
      if (this.map) {
        var media = this.$.sceneMedia;
        var image = this.$.image
        var toggle = this.$.toggle;
        media.style.display = 'none';
        image.style.display = 'none';
        toggle.innerHTML = "Hide content";
        var bounds = new google.maps.LatLngBounds();
        for (var i in indices) {
          bounds.extend(this.totalPath[indices[i]]);
        }
        this.map.fitBounds(bounds);
        this.uponMapIdle(this.panToScene);
      }
    },

    /**
     * Pan to the upcoming scene (the scene that `index` points to).
     *
     * @method panToScene
     */
    panToScene: function() {
      if (this.map) {
        this.totalPathChanged();
        if (!this.map.getCenter().equals(this.totalPath[this.index])) {
          this.map.panTo(this.totalPath[this.index]);
          this.uponMapIdle(this.activateScene);
        } else {
          // if the map is already centered, activate the scene
          this.activateScene();
        }
      }
    },

    /**
     * Activate the upcoming scene.
     *
     * @method activateScene
     */
    activateScene: function() {
      if (this.map) {
        var scene = this.scenes[this.index];
        this.map.setZoom(scene.zoom);
        this.map.setCenter(scene.location);
        this.currentScene = scene;
        this.current = scene.id;
        this.updateContent();
      }
    },

    makeButton: function(id, title, text, controlPosition, onClick) {
      var button = document.createElement('button');
      button.id = id;
      button.title = title;
      var content = document.createTextNode(text);
      button.appendChild(content);
      google.maps.event.addDomListener(button, 'click', onClick.bind(this));
      this.map.controls[controlPosition].insertAt(0, button);
    },

    makePolyline: function(opacity) {
      var dash = {
        path: 'M 0,0 0,1',  // This is the svg for a dash.
        strokeOpacity: opacity,
        scale: 2
      };
      // The dash symbol (see icons) is repeated every 2px to form a solid line.
      var lineOptions = {
        map: this.map,
        geodesic: true,
        strokeOpacity: 0,  // The line underneath the dashes is not visible.
        icons: [{
          icon: dash,
          offset: '0px',
          repeat: '2px'
        }]
      };
      return new google.maps.Polyline(lineOptions);
    }

  });
})();
</script>
</polymer-element>
