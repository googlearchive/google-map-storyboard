<!--
The 'google-map-storyboard' renders a Google Map with 'google-map-scene' elements.

<b>Example</b> Add scenes to the map and traverse them linearly:

    <style>
      google-map-storyboard {
        height: 600px;
      }
    </style>
    <google-map-storyboard>
      <google-map-scene address="Sydney, Australia" zoom="5">This is Sydney!</google-map-scene>
      <google-map-scene address="Zurich, Switzerland"></google-map-scene>
    </google-map-storyboard>


@element google-map-storyboard
@homepage https://github.com/googlemaps/google-map-storyboard
-->
<!--
Fired when the storybord's google map is ready to be rendered.

@event google-map-storyboard-ready
-->
<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/google-apis/google-apis.html">
<link rel="import" href="google-map-scene.html">

<polymer-element name="google-map-storyboard" attributes="apiKey current showMarkers disableDefaultUI">
<template>
  <style>

    :host {
      position: relative;
      display: block;
      height: 100%;
    }

    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    button {
      opacity: 0.5;
      font-size: 1.5em;
      outline: none;
      border-radius: 50%;
      background-color: #fff;
    }

    button:hover {
      opacity: 1;
    }
    
  </style>

  <google-maps-api apiKey="{{apiKey}}" version="3.exp" libraries="places,geometry" on-api-load="{{mapApiLoaded}}"></google-maps-api>

  <div id="map"></div>

  <content id="scenes" select="google-map-scene" on-scene-location-changed="{{updateScenes}}"></content>
</template>


<script>
(function() {
  Polymer({

    /**
     * Array of the google-map-scenes contained within the storyboard.
     * 
     * @property scenes
     * @type Array.google-map-scene
     * @default null
     */
    scenes: null,

    /**
     * The google map used in the storyboard.
     * 
     * @property map
     * @type google.maps.Map
     * @default null
     */
    map: null,

    /**
     * The Google Map API key. To obtain an API key, 
     * see developers.google.com/maps/documentation/javascript/tutorial#api_key.
     * 
     * @attribute apiKey
     * @type string
     * @default null
     */
    apiKey: null,

    publish: {
      /**
       * The id of the scene to be shown.
       * 
       * @attribute current
       * @type String
       * @default null
       */
      current: {value: null, reflect: true}
    },

    /**
     * If true, there is a marker shown at each scene.
     *
     * @attribute showMarkers
     * @type Boolean
     * @default true
     */
    showMarkers: true,

    /**
     * If true, removes the map's default UI controls.
     *
     * @attribute disableDefaultUI
     * @type Boolean
     * @default true
     */
    disableDefaultUI: true,

    /**
     * The index of the upcoming scene.
     * 
     * @property index
     * @type Number
     * @default 0
     */
    index: 0,

    /**
     * The current scene. Initialised to the first scene.
     *
     * @property currentScene
     * @type google-map-scene
     * @default null
     */
    currentScene: null,

    /**
     * The intervalId of the current line animation frame.
     * Null if there is no current animation frame.
     *
     * @property intervalId
     * @type Number
     * @default null
     */
    intervalId: null,

    /**
     * Duration of each line animation in milliseconds.
     *
     * @property ANIMATION_TIME_MS
     * @type Number
     * @default 5000
     */
    ANIMATION_TIME_MS: 3000,

    mapApiLoaded: function() {
      this.initializeScenes();
    },

    initializeMap: function() {
      if (!this.map) {
        var mapOptions = {
          center: this.currentScene.location,
          zoom: this.currentScene.zoom,
          disableDefaultUI: this.disableDefaultUI
        };
        this.map = new google.maps.Map(this.$.map, mapOptions);
        this.makeButton("prev", "Previous", "<", 
            google.maps.ControlPosition.LEFT_CENTER, this.getPrev);
        this.makeButton("next", "Next", ">", 
            google.maps.ControlPosition.RIGHT_CENTER, this.getNext);
        this.infowindow = new google.maps.InfoWindow;
        this.updateControls();
        this.updateScenes();
        this.activateScene();
        this.fire('google-map-storyboard-ready');
      }
    },

    checkReady: function() {
      for (var i = 0, scene; i < this.scenes.length; ++i) {
        var scene = this.scenes[i];
        if (!scene.location) return;
      }
      this.initializeMap();
    },

    initializeScenes: function() {
      this.scenes = Array.prototype.slice.call(
          this.$.scenes.getDistributedNodes());
      this.updateLocations();
    },

    updateContent: function() {
      if (!this.map) return;
      var currentNode = this.scenes[this.index].firstChild;
      var contentString = '';
      if (currentNode) {
        contentString = currentNode instanceof HTMLImageElement ?
          currentNode.outerHTML : 
          currentNode.textContent;
      }
      this.infowindow.setContent(contentString);
      if (this.scenes[this.index].marker) {
        if (currentNode) {
          this.infowindow.open(this.map,this.scenes[this.index].marker);
        }
      } else {
        this.infowindow.setPosition(this.currentScene.location);
        if (currentNode) {
          this.infowindow.open(this.map);
        }
      }
      google.maps.event.addListener(this.map, 'zoom_changed',
          onInteraction.bind(this));
      google.maps.event.addListener(this.map, 'center_changed',
          onInteraction.bind(this));
      function onInteraction(){
        this.infowindow.close();
      }
      google.maps.event.addListener(this.scenes[this.index].marker, 'click', changeContent.bind(this));
      function changeContent() {
        if (this.infowindow.getMap()) {
          if (currentNode.nextSibling != null){
            currentNode = currentNode.nextSibling;
            if (currentNode instanceof HTMLImageElement) {
              this.infowindow.setContent(currentNode.outerHTML);
            }
            else {
              this.infowindow.setContent(currentNode.textContent);
            }
          } else {
            currentNode = this.currentScene.firstChild;
            if (currentNode instanceof HTMLImageElement) {
              this.infowindow.setContent(currentNode.outerHTML);
            }
            else {
              this.infowindow.setContent(currentNode.textContent);
            }
          } google.maps.event.trigger(this.infowindow, 'resize');
        }
        else {
          if (currentNode) {
	    this.infowindow.open(this.map, this.scenes[this.index].marker);
          }
        }
      }
    },

    updateLocations: function() {
      this.currentScene = this.currentScene || this.scenes[this.index];
      this.geocoder = this.geocoder || new google.maps.Geocoder();
      for (var i = 0; i < this.scenes.length; ++i) {
        var scene = this.scenes[i];
        if (scene.location instanceof google.maps.LatLng) continue;
        (function(index) {
          this.geocoder.geocode({address: scene.address}, 
              function(place, status) {
            if (status == google.maps.GeocoderStatus.OK) {
              var scene = this.scenes[index];
              scene.location = place[0].geometry.location;
              if (scene === this.currentScene) {
                this.index = index;
                this.current = scene.id;
                scene.locationChanged();
              }
            }
            this.checkReady();
          }.bind(this));
        }.bind(this))(i);
      }
    },

    updateScenes: function() {
      this.updateTotalPath();
      if (this.showMarkers) this.showMarkersChanged();
    },

    showMarkersChanged: function() {
      if (!this.map) return;
      var map = (this.showMarkers && this.map) || null;
      for (var i in this.scenes) {
        var marker = this.scenes[i].marker;
        if (marker) marker.setMap(map);
      }
    },

    disableDefaultUIChanged: function() {
      if (!this.map) return;
      this.map.setOptions({
        disableDefaultUI: this.disableDefaultUI
      });
    },

    currentChanged: function() {
      var scene = document.getElementById(this.current);
      if (!scene || scene.element.name != 'google-map-scene') {
        return;
      }
      if (this.scenes) {
        var sceneIndex = this.scenes.indexOf(scene);
        if (sceneIndex != this.index) {
          var oldIndex = this.index.valueOf();
          this.index = sceneIndex;
          this.updateTotalPath();
          this.fitBounds([oldIndex, this.index], true);
        }
      } else {
        this.currentScene = scene;
      }
    },

    indexChanged: function() {
      if (this.map) {
        this.updateControls();
      }
    },

    getPrev: function() {
      if (this.index > 0) {
        var from = this.index.valueOf();
        this.index--;
        this.startAnimation(from, from - 1);
      }
    },

    getNext: function() {
      if (this.index < this.scenes.length - 1) {
        var from = this.index.valueOf();
        this.index++;
        this.startAnimation(from, from + 1);
      }
    },

    updateControls: function() {
      var control = this.map.controls[google.maps.ControlPosition.LEFT_CENTER];
      if (this.index < 1) {
        this.prevButton = this.prevButton || control.removeAt(0);
      } else if (this.prevButton) {
        control.insertAt(0, this.prevButton);
        this.prevButton = null;
      }

      control = this.map.controls[google.maps.ControlPosition.RIGHT_CENTER];
      if (this.index > this.scenes.length - 2) {
        this.nextButton = this.nextButton || control.removeAt(0);
      } else if (this.nextButton) {
        control.insertAt(0, this.nextButton);
        this.nextButton = null;
      }
    },

    // TODO: Decide on behaviour at invalid locations and implement.
    updateTotalPath: function() {
      if (this.map) {
        this.stopAnimation(false);
        this.prevLine = this.prevLine || this.makePolyline(0.4);
        this.nextLine = this.nextLine || this.makePolyline(0.2);
        var prevPath = this.prevLine.getPath().getArray();
        var nextPath = this.nextLine.getPath().getArray();
        var totalPath = prevPath.concat(nextPath.slice(0,-1).reverse());
        // If the totalPath is incomplete, add points to the path until it is
        // complete, or until it reaches a scene without a location.
        // The totalPath and polyline is not constructed passed
        // an invalid location.
        for (var i = totalPath.length, scene; scene = this.scenes[i]; ++i) {
          if (!scene.location) break;
          totalPath.push(scene.location);
        }
        // Previous line path contains the points up to and including index
        this.prevLine.setPath(totalPath.slice(0, this.index + 1));
        // Next line path contains the points from the end to index (inclusive)
        this.nextLine.setPath(totalPath.slice(this.index).reverse());
      }
    },

    /**
     * @method uponMapIdle
     * @param {Function} handler The handler to call when the map is idle.
     * Will replace the existing idle handler. If null, removes the current
     * idle handler.
     */
    uponMapIdle: function(handler) {
      google.maps.event.removeListener(this.idleListener);
      if (handler) {
        this.idleListener = new google.maps.event.addListenerOnce(this.map,
            'idle', handler.bind(this));
      }
    },

    /**
     * Fit the bounds of the map to the given scene locations.
     * The first stage of the default transition to a scene.
     * The default transition to a scene:
     *   - `fitBounds -> panToScene -> activateScene`
     *   - each change of state [`->`] occurs when the map is `idle`
     *
     * @method fitBounds
     * @param {Array.Number} indices Indices of scenes to fit in the bounds.
     * @param {Boolean} continueTransition If true, continue default transition.
     */
    fitBounds: function(indices, continueTransition) {
      if (this.map) {
        var bounds = new google.maps.LatLngBounds();
        for (var i in indices) {
          bounds.extend(this.scenes[indices[i]].location);
        }
        this.map.fitBounds(bounds);
        if (continueTransition) this.uponMapIdle(this.panToScene);
      }
    },

    /**
     * Pan to the upcoming scene (the scene that `index` points to).
     *
     * @method panToScene
     */
    panToScene: function() {
      if (this.map) {
        if (!this.map.getCenter().equals(this.scenes[this.index].location)) {
          this.map.panTo(this.scenes[this.index].location);
          this.uponMapIdle(this.activateScene);
        } else {
          // If the map is already centered, activate the scene.
          this.activateScene();
        }
      }
    },

    /**
     * Activate the upcoming scene.
     *
     * @method activateScene
     */
    activateScene: function() {
      if (this.map) {
        var scene = this.scenes[this.index];
        this.map.setZoom(scene.zoom);
        this.map.setCenter(scene.location);
        this.currentScene = scene;
        this.current = scene.id;
        this.updateContent();
      }
    },

    /**
     * Makes a button which is added to the map controls.
     *
     * @method makeButton
     * @param {String} id The button's id.
     * @param {String} title The button's title.
     * @param {String} text The text shown inside the button.
     * @param {google.map.ControlPosition} controlPosition Position on the map.
     * @param {Function} onClick The handler for a click event.
     */
    makeButton: function(id, title, text, controlPosition, onClick) {
      var button = document.createElement('button');
      button.id = id;
      button.title = title;
      var content = document.createTextNode(text);
      button.appendChild(content);
      google.maps.event.addDomListener(button, 'click', onClick.bind(this));
      this.map.controls[controlPosition].insertAt(0, button);
    },

    /**
     * Makes a polyline with the given opacity.
     *
     * @method makePolyline
     * @param {Number} opacity The opacity of the polyline.
     * @returns {google.maps.Polyline} The polyline created.
     */
    makePolyline: function(opacity) {
      var dash = {
        path: 'M 0,0 0,1',  // This is the svg for a dash.
        strokeOpacity: opacity,
        scale: 2
      };
      // The dash symbol (see icons) is repeated every 2px to form a solid line.
      var lineOptions = {
        map: this.map,
        geodesic: true,
        strokeOpacity: 0,  // The line underneath the dashes is not visible.
        icons: [{
          icon: dash,
          offset: '0px',
          repeat: '2px'
        }]
      };
      return new google.maps.Polyline(lineOptions);
    },

    /**
     * Start a line animation moving between the scenes indexed 'from' and 'to'.
     * If another line animation/transition is in progress, stop it.
     *
     * @method startAnimation
     * @param {Number} from The index of the scene it is animating from.
     * @param {Number} to The index of the scene it is animating to.
     */
    startAnimation: function(from, to) {
      if (!this.map) return;
      this.uponMapIdle(null);
      this.stopAnimation(false);

      this.async(function() {
        this.forward = (to > from);
        var line = (!this.forward && this.nextLine) || this.prevLine;
        line.getPath().push(getLast(line));
        this.fitBounds([from, to], false);
        /* NOTE: requestAnimationFrame gives the DOMHighResTimeStamp as the
         * last parameter in the callback. (The 3rd parameter in this case.)
         */
        this.intervalId = window.requestAnimationFrame(
            step.bind(this, from, to));
      });
    },

    /**
     * Stops the current line animation.
     *
     * @method stopAnimation
     * @param {Boolean} finishTransition If true, finishes default transition.
     */
    stopAnimation: function(finishTransition) {
      if (typeof this.intervalId != 'number') return;
      window.cancelAnimationFrame(this.intervalId);
      this.intervalId = null;
      var shortenLine = (this.forward && this.nextLine) || this.prevLine;
      shortenLine.getPath().pop();
      var line = (!this.forward && this.nextLine) || this.prevLine;
      setLast(line, getLast(shortenLine));
      if (finishTransition) this.panToScene();
    }

  });

  /**
   * A step/frame of the line animation.
   * Note: Expects `this` to be the storyboard.
   *
   * @method step
   * @param {Number} from The index of the scene it is animating from.
   * @param {Number} to The index of the scene it is animating to.
   * @param {DOMHighResTimeStamp} startTime The animation start time.
   * @param {DOMHighResTimeStamp} currentTime Optional, defaults to startTime.
   */
  function step(from, to, startTime, currentTime) {
    if (!currentTime) currentTime = startTime;
    var diffTime = currentTime - startTime;
    var offset = (diffTime / this.ANIMATION_TIME_MS);
    if (offset >= 1) {
      this.stopAnimation(true);
      return;
    }

    var wayPoint = new google.maps.geometry.spherical.interpolate(
        this.scenes[from].location, this.scenes[to].location, offset);
    setLast(this.nextLine, wayPoint);
    setLast(this.prevLine, wayPoint);

    this.intervalId = window.requestAnimationFrame(
        step.bind(this, from, to, startTime));
  }

  function setLast(line, point) {
    var path = line.getPath();
    path.setAt(path.length - 1, point);
  }

  function getLast(line) {
    var path = line.getPath();
    return path.getAt(path.length - 1);
  }

})();
</script>
</polymer-element>
